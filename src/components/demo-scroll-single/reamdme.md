背景：
之前在做NFT交易所的时候，遇到瀑布流布局的滚动加载，遇到一个性能上可有优化的点。
现在把优化方式用整理一下，实现一个类似的demo。

需求： 多列展示，滚动加载，假设数量会异常多。

场景一：
同宽不等高，单列滚动加载。
基础。


场景二：
每个元素同宽，不等高，多列瀑布流布局，下拉滚动加载;

大致过程：
先分列，下拉滚动达到阀值后，
取定长元素，然后找出最短列，把一个元素加入最短列。重复找最短列合填值，知道定长元素分配完。这其实是限定数量的瀑布流布局的一个方式，防止最后每列高度差过大。 
准备两个列表，分别存放虚拟列表上方被删除的数据 topList，和虚拟列表下方被删除的数据bottomList。每个被删除的item加载入暂存数列时，补充其所属的列belong属性 ，方便加载的时候直接使用。   
删除虚拟列表的长度时，无论是删除上方还是下方的数据，都按先删除最高列来。反之加载的时候，按顺序从列表中按顺序加载，再根据belong属性分配到各自列。 

业务要是无限加载，可以不用找最短列，直接按顺序排。这里Demo先不考虑按最短列排，因为重点是在处理无限滚动上。之后看需要，可以补上按最短列排布。  


与单列相比，滚动区域的逻辑大致一样，不一样的重点是在怎么规划每一列的删除项和增加项，让整个视觉区域位置不变。   

视觉区域不变？  
也就是当我们回收展示的每列items顶部隐藏的部分元素时，怎么保持每列删除后的每列的新初始值的位置是‘互相相对静止的’。  
因为我们每个元素不等高，每列删除相等高度的元素不切实际。所以，换个方式，在每列的开头增加一个填充元素，然后每列从1开始删除，每列删除元素的高度差通过调节填充元素来填充，达到相对静止。
